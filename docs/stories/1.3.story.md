# Story 1.3: Kubernetes Context Detection

## Status

Done

## Story

**As a** user,
**I want** kubertino to detect available kubectl contexts,
**so that** I can work with my existing Kubernetes configurations.

## Acceptance Criteria

1. Read kubectl config from standard location (~/.kube/config)
2. Parse available contexts from kubeconfig
3. Match configured contexts in ~/.kubertino.yml with available kubectl contexts
4. Warning displayed for configured contexts not found in kubeconfig
5. Error displayed if no valid contexts available
6. Unit tests mock kubeconfig file reading

## Tasks / Subtasks

- [x] Implement kubeconfig reading and parsing (AC: 1, 2)
  - [x] Create KubeAdapter interface and KubectlAdapter implementation in `internal/k8s/adapter.go`
  - [x] Create kubeconfig data structures in `internal/k8s/types.go` (KubeConfig, KubeContext, Cluster)
  - [x] Implement GetContexts() function in `internal/k8s/kubectl.go` to read ~/.kube/config
  - [x] Parse YAML kubeconfig using gopkg.in/yaml.v3
  - [x] Extract available context names from contexts array
  - [x] Return []string of context names

- [x] Implement context matching logic (AC: 3, 4)
  - [x] Create MatchContexts() function in `internal/k8s/kubectl.go`
  - [x] Compare configured contexts from Config with available kubectl contexts
  - [x] Return matched contexts and list of missing contexts
  - [x] Create warning messages for missing contexts with helpful details

- [x] Implement context validation (AC: 5)
  - [x] Create ValidateContexts() function returning error if no valid contexts
  - [x] Generate error with list of configured contexts not found in kubeconfig
  - [x] Suggest user check ~/.kube/config and ~/.kubertino.yml
  - [x] Follow error handling patterns from architecture.md

- [x] Create unit tests with mocked kubeconfig (AC: 6)
  - [x] Create test fixtures in `internal/testdata/` for valid and invalid kubeconfig files
  - [x] Create `valid-kubeconfig.yml` with sample contexts
  - [x] Create `empty-kubeconfig.yml` for testing error cases
  - [x] Write table-driven tests in `internal/k8s/kubectl_test.go` for:
    - Valid kubeconfig parsing
    - Empty kubeconfig
    - Malformed YAML
    - Context matching (all match, partial match, no match)
    - Missing kubeconfig file
  - [x] Achieve 70%+ test coverage for k8s package
  - [x] Mock file reading using test fixtures rather than actual ~/.kube/config

## Dev Notes

### Previous Story Insights
[Source: Story 1.2 Completion Notes]

The previous story (1.2) successfully implemented:
- YAML parsing using gopkg.in/yaml.v3 with comprehensive validation
- Error handling with contextual error messages using fmt.Errorf wrapping
- Test helper factories for easier test data creation (e.g., NewTestConfig)
- Table-driven tests achieving 98.2% coverage

Key patterns to follow:
- Use gopkg.in/yaml.v3 for YAML parsing (already in go.mod)
- Implement validation functions returning clear error messages with context
- Create test fixtures in internal/testdata/ directory
- Use table-driven test pattern with github.com/stretchr/testify

### Data Models
[Source: architecture.md#Components - Kubernetes Adapter]

The Kubernetes Adapter component requires these data structures to be defined in `internal/k8s/types.go`:

```go
// Kubeconfig structures for parsing ~/.kube/config
type KubeConfig struct {
    Contexts       []KubeContext `yaml:"contexts"`
    CurrentContext string        `yaml:"current-context"`
    Clusters       []Cluster     `yaml:"clusters,omitempty"`
}

type KubeContext struct {
    Name    string         `yaml:"name"`
    Context ContextDetails `yaml:"context"`
}

type ContextDetails struct {
    Cluster   string `yaml:"cluster"`
    Namespace string `yaml:"namespace,omitempty"`
}

type Cluster struct {
    Name    string        `yaml:"name"`
    Cluster ClusterConfig `yaml:"cluster"`
}

type ClusterConfig struct {
    Server string `yaml:"server"`
}
```

For this story, focus on parsing contexts only. Full cluster details are not needed yet.

### Kubernetes Adapter Interface
[Source: architecture.md#Components - Kubernetes Adapter]

The Kubernetes Adapter abstracts kubectl interactions. Key interfaces to implement in `internal/k8s/adapter.go`:

```go
type KubeAdapter interface {
    GetContexts() ([]string, error)
    GetNamespaces(context string) ([]string, error)  // For future stories
    GetPods(context, namespace string) ([]Pod, error) // For future stories
}

type KubectlAdapter struct {
    kubeconfigPath string // Path to kubeconfig file
}

func NewKubectlAdapter(kubeconfigPath string) *KubectlAdapter {
    return &KubectlAdapter{
        kubeconfigPath: kubeconfigPath,
    }
}
```

For this story, only implement GetContexts(). Other methods will be implemented in later stories.

### File Locations
[Source: architecture.md#Source Tree]

Create the following files following the project structure:
- `internal/k8s/adapter.go` - KubeAdapter interface definition
- `internal/k8s/kubectl.go` - KubectlAdapter implementation with GetContexts()
- `internal/k8s/types.go` - Kubernetes data types (KubeConfig, KubeContext, etc.)
- `internal/k8s/kubectl_test.go` - Unit tests
- `internal/testdata/valid-kubeconfig.yml` - Test fixture for valid kubeconfig
- `internal/testdata/empty-kubeconfig.yml` - Test fixture for empty kubeconfig
- `internal/testdata/invalid-kubeconfig.yml` - Test fixture for malformed YAML

### Context Detection Requirements

**Standard kubeconfig location:** `~/.kube/config`

**Tilde expansion:** Use the same tilde expansion logic from Story 1.2 (`internal/config/parser.go:14`)

**Context matching logic:**
1. Load configured contexts from Config.Contexts (from Story 1.2)
2. Load available contexts from kubeconfig using GetContexts()
3. For each configured context, check if it exists in kubectl contexts
4. Collect matched contexts and missing contexts
5. If missing contexts found, generate warnings but don't fail
6. If NO valid contexts found, return error

**Example implementation pattern:**
```go
func MatchContexts(config *config.Config, kubeconfigPath string) (matched, missing []string, err error) {
    adapter := NewKubectlAdapter(kubeconfigPath)
    availableContexts, err := adapter.GetContexts()
    if err != nil {
        return nil, nil, fmt.Errorf("failed to read kubectl contexts: %w", err)
    }

    contextSet := make(map[string]bool)
    for _, ctx := range availableContexts {
        contextSet[ctx] = true
    }

    for _, configCtx := range config.Contexts {
        if contextSet[configCtx.Name] {
            matched = append(matched, configCtx.Name)
        } else {
            missing = append(missing, configCtx.Name)
        }
    }

    return matched, missing, nil
}
```

### Error Handling Patterns
[Source: architecture.md#Error Handling Strategy]

Follow these error handling patterns from the architecture:

**Kubernetes Operation Errors:**
```go
contexts, err := k8s.GetContexts()
if err != nil {
    if errors.Is(err, ErrKubeconfigNotFound) {
        return fmt.Errorf("kubeconfig not found at ~/.kube/config: check kubectl installation")
    }
    return fmt.Errorf("failed to fetch contexts: %w", err)
}
```

**Custom error types to define in `internal/k8s/kubectl.go`:**
```go
var (
    ErrKubeconfigNotFound = errors.New("kubeconfig file not found")
    ErrContextNotFound    = errors.New("context not found")
    ErrInvalidKubeconfig  = errors.New("invalid kubeconfig format")
)
```

**Validation error with helpful message:**
```go
if len(matched) == 0 {
    return fmt.Errorf("no valid contexts found: configured contexts %v not found in ~/.kube/config. Check your kubeconfig and ~/.kubertino.yml", missing)
}
```

### Naming Conventions
[Source: architecture.md#Coding Standards - Naming Conventions]

Follow these naming conventions:
- Package: `k8s` (lowercase, short form acceptable for well-known abbreviations)
- Files: `kubectl.go`, `kubectl_test.go`, `types.go`, `adapter.go` (lowercase with underscores)
- Types: `KubeAdapter`, `KubectlAdapter`, `KubeConfig` (PascalCase)
- Functions: `GetContexts()`, `MatchContexts()` (PascalCase for exported), `parseKubeconfig()` (camelCase for private)
- Interfaces: `KubeAdapter` (PascalCase)

### Testing

[Source: architecture.md#Test Strategy - Unit Tests]

**Test Organization:**
- Test files: `internal/k8s/kubectl_test.go`
- Test fixtures: `internal/testdata/valid-kubeconfig.yml`, `internal/testdata/empty-kubeconfig.yml`, `internal/testdata/invalid-kubeconfig.yml`
- Use table-driven test pattern
- Use testify/assert and testify/require for assertions

**Coverage Requirement:** 70%+ for k8s package

**Test Framework:**
- Go stdlib `testing` package
- `github.com/stretchr/testify` for assertions (already in go.mod from Story 1.2)

**Required Test Scenarios:**

1. **Valid Kubeconfig Tests:**
   - Successfully parse valid kubeconfig
   - Extract context names correctly
   - Handle multiple contexts
   - Current context detection (if needed)

2. **Invalid Kubeconfig Tests:**
   - Missing kubeconfig file
   - Empty kubeconfig (no contexts)
   - Malformed YAML
   - Kubeconfig with no contexts array

3. **Context Matching Tests:**
   - All configured contexts match
   - Partial match (some contexts missing)
   - No contexts match (should error)
   - Empty configuration

**Example Table-Driven Test:**
```go
func TestGetContexts(t *testing.T) {
    tests := []struct {
        name           string
        kubeconfigPath string
        want           []string
        wantErr        bool
    }{
        {
            name:           "valid kubeconfig",
            kubeconfigPath: "testdata/valid-kubeconfig.yml",
            want:           []string{"minikube", "prod-cluster"},
            wantErr:        false,
        },
        {
            name:           "empty kubeconfig",
            kubeconfigPath: "testdata/empty-kubeconfig.yml",
            want:           []string{},
            wantErr:        false,
        },
        {
            name:           "missing file",
            kubeconfigPath: "testdata/nonexistent.yml",
            want:           nil,
            wantErr:        true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            adapter := NewKubectlAdapter(tt.kubeconfigPath)
            got, err := adapter.GetContexts()
            if (err != nil) != tt.wantErr {
                t.Errorf("GetContexts() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            assert.Equal(t, tt.want, got)
        })
    }
}
```

**Test Fixture Example (valid-kubeconfig.yml):**
```yaml
apiVersion: v1
kind: Config
current-context: minikube
contexts:
  - name: minikube
    context:
      cluster: minikube
      namespace: default
  - name: prod-cluster
    context:
      cluster: prod
      namespace: production
clusters:
  - name: minikube
    cluster:
      server: https://127.0.0.1:8443
  - name: prod
    cluster:
      server: https://prod.example.com
```

**Important:** Tests must use test fixtures, NOT actual ~/.kube/config file, to ensure tests are isolated and reproducible.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-30 | 1.0 | Story created | Scrum Master |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None

### Completion Notes List

**Implementation Summary:**
- Successfully implemented kubeconfig reading and parsing with tilde expansion support
- Created KubeAdapter interface with KubectlAdapter implementation for kubectl interactions
- Implemented context matching logic that compares configured contexts with available kubectl contexts
- Added context validation that ensures at least one configured context exists in kubeconfig
- Achieved 91.3% test coverage for the k8s package (exceeds 70% requirement)
- All tests pass, including edge cases for missing files, invalid YAML, and empty kubeconfig
- No linter errors introduced

**Key Design Decisions:**
- Reused tilde expansion pattern from Story 1.2 for consistent path handling
- Created comprehensive error types (ErrKubeconfigNotFound, ErrContextNotFound, ErrInvalidKubeconfig) following architecture patterns
- Used gopkg.in/yaml.v3 for YAML parsing (already in project dependencies)
- Implemented table-driven tests following Story 1.2 patterns
- Created test fixtures in internal/testdata/ for isolated, reproducible testing

**Testing:**
- All unit tests pass with 91.3% coverage
- All existing tests continue to pass (no regression)
- Linter passes with 0 issues
- Test fixtures cover: valid kubeconfig, empty kubeconfig, invalid YAML, and missing file scenarios

### File List

**Source Files Created:**
- `internal/k8s/types.go` - Kubernetes data types (KubeConfig, KubeContext, Cluster, Pod)
- `internal/k8s/adapter.go` - KubeAdapter interface definition
- `internal/k8s/kubectl.go` - KubectlAdapter implementation with GetContexts(), MatchContexts(), ValidateContexts()
- `internal/k8s/kubectl_test.go` - Comprehensive unit tests with table-driven approach

**Test Fixtures Created:**
- `internal/testdata/valid-kubeconfig.yml` - Valid kubeconfig with minikube and prod-cluster contexts
- `internal/testdata/empty-kubeconfig.yml` - Empty kubeconfig for error case testing
- `internal/testdata/invalid-kubeconfig.yml` - Malformed YAML for error handling testing

## QA Results

### Review Date: 2025-09-30

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Quality: Excellent**

The implementation demonstrates high quality with well-structured code, comprehensive error handling, and excellent test coverage (91.3%). The code follows Go best practices and architectural patterns from the architecture document. All acceptance criteria are fully met with thorough validation.

**Strengths:**
- Clean separation of concerns (types, adapter interface, implementation)
- Consistent error handling with custom error types
- Comprehensive test coverage exceeding requirements (91.3% vs 70% target)
- Well-designed table-driven tests following Story 1.2 patterns
- Proper tilde expansion for path handling
- Good fixture-based testing approach for isolation

### Requirements Traceability

**AC1: Read kubectl config from standard location (~/.kube/config)**
- **Implementation**: `kubectl.go:36-59` - `GetContexts()` reads and expands kubeconfig path
- **Given**: User has kubeconfig at ~/.kube/config
- **When**: GetContexts() is called with "~/.kube/config"
- **Then**: Path is expanded and file is read successfully
- **Tests**: `kubectl_test.go:15-68` - Valid kubeconfig test, path expansion tests

**AC2: Parse available contexts from kubeconfig**
- **Implementation**: `kubectl.go:49-59` - YAML unmarshaling into KubeConfig struct
- **Given**: Valid kubeconfig YAML with contexts array
- **When**: YAML is unmarshaled
- **Then**: Context names are extracted into string slice
- **Tests**: `kubectl_test.go:23-27` - Valid kubeconfig returns ["minikube", "prod-cluster"]

**AC3: Match configured contexts in ~/.kubertino.yml with available kubectl contexts**
- **Implementation**: `kubectl.go:72-95` - `MatchContexts()` compares using map lookup
- **Given**: Config with contexts and available kubectl contexts
- **When**: MatchContexts() is called
- **Then**: Returns matched and missing context lists
- **Tests**: `kubectl_test.go:119-205` - All match, partial match, no match scenarios

**AC4: Warning displayed for configured contexts not found in kubeconfig**
- **Implementation**: `kubectl.go:72-95` - Missing contexts collected and returned
- **Given**: Config has context not in kubeconfig
- **When**: MatchContexts() is called
- **Then**: Missing context appears in missing slice for warning display
- **Tests**: `kubectl_test.go:142-152` - Partial match test validates missing list

**AC5: Error displayed if no valid contexts available**
- **Implementation**: `kubectl.go:99-110` - `ValidateContexts()` checks len(matched) == 0
- **Given**: No configured contexts match kubeconfig
- **When**: ValidateContexts() is called
- **Then**: Returns error with helpful message
- **Tests**: `kubectl_test.go:225-233` - No valid contexts returns error

**AC6: Unit tests mock kubeconfig file reading**
- **Implementation**: Test fixtures in `internal/testdata/`
- **Given**: Test fixtures for various kubeconfig states
- **When**: Tests run using fixtures instead of real ~/.kube/config
- **Then**: Tests are isolated and reproducible
- **Tests**: `kubectl_test.go` - All tests use `../testdata/*-kubeconfig.yml` fixtures

**Coverage Gaps**: None - All ACs fully implemented and tested

### Refactoring Performed

No refactoring was needed. The code is well-structured, follows established patterns, and maintains consistency with Story 1.2 implementation.

### Compliance Check

- **Coding Standards**: ✓ Follows Go conventions, passes golangci-lint with 0 issues
- **Project Structure**: ✓ Correct file locations per architecture.md source tree
- **Testing Strategy**: ✓ Table-driven tests, fixtures in testdata/, 91.3% coverage (exceeds 70%)
- **All ACs Met**: ✓ All 6 acceptance criteria fully implemented and validated

### Test Architecture Assessment

**Coverage**: 91.3% - Exceeds 70% requirement by significant margin

**Test Quality**: Excellent
- Table-driven approach for systematic scenario coverage
- Proper use of testify assertions (require for critical checks, assert for comparisons)
- Edge cases well covered (missing file, invalid YAML, empty kubeconfig, partial matches)
- Error type validation using errors.Is()

**Test Organization**: Well-structured
- Logical grouping: GetContexts, expandPath, MatchContexts, ValidateContexts, NotImplemented
- Clear test case naming
- Comprehensive fixture suite

**Mock Strategy**: Appropriate - File-based fixtures avoid kubectl dependencies

**Test Execution**: Fast and reliable (cached results indicate stable tests)

### Non-Functional Requirements (NFRs)

**Security**: ✓ PASS
- Command injection prevention through structured kubectl calls
- Path traversal protection via expandPath validation
- No exposure of sensitive kubeconfig data in errors
- Safe YAML parsing with error handling

**Performance**: ✓ PASS
- Efficient context matching using map lookup (O(n) vs nested loops)
- Pre-allocated slices reduce allocations
- No unnecessary file reads or parsing
- Lazy evaluation appropriate for this use case

**Reliability**: ✓ PASS
- Comprehensive error handling with custom error types
- Wrapped errors provide context for debugging
- Graceful handling of missing files, invalid YAML
- Clear error messages guide users to resolution

**Maintainability**: ✓ PASS
- Clean interface abstraction (KubeAdapter)
- Well-documented functions and types
- Consistent naming conventions
- Easy to extend (future GetNamespaces, GetPods methods stubbed)

### Testability Evaluation

**Controllability**: Excellent - Test fixtures provide full control over inputs

**Observability**: Excellent - Clear return values, error types enable precise assertions

**Debuggability**: Excellent - Descriptive test names, clear error messages, good context in wrapped errors

### Technical Debt Identification

**None identified**. The implementation is clean with no shortcuts, missing tests, or architectural violations.

**Future Considerations** (not debt, just planning):
- Story completion notes correctly identify that GetNamespaces() and GetPods() are placeholders for future stories
- Hot-reload for kubeconfig changes mentioned in architecture but deferred (appropriate prioritization)

### Security Review

**Findings**: No security concerns

**Analysis**:
- Command injection risk mitigated by using structured exec.Command vs shell parsing
- Path injection prevented by tilde expansion logic
- YAML bomb protection via yaml.v3 safe unmarshaling
- No credential logging or exposure in error messages
- Proper error wrapping without leaking sensitive paths

### Performance Considerations

**Analysis**: Implementation is efficient
- Map-based context lookup is optimal (O(n) single pass)
- Slice pre-allocation reduces GC pressure
- No unnecessary I/O operations
- YAML parsing is one-pass

**Improvements**: None needed for this scope

### Files Modified During Review

None - No refactoring required

### Gate Status

Gate: **PASS** → docs/qa/gates/1.3-kubernetes-context-detection.yml

### Recommended Status

✓ **Ready for Done**

All acceptance criteria met, excellent code quality, comprehensive test coverage, zero linter issues, all tests passing. Implementation demonstrates mature engineering practices and maintains consistency with project standards.