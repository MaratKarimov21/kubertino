# Story 3.3: Pod List Navigation

## Status

Done

## Story

**As a** user,
**I want** to navigate the pod list with keyboard,
**so that** I can inspect different pods (future: execute pod-specific actions).

## Acceptance Criteria

1. Tab key switches focus between namespace and pod panels
2. Arrow keys navigate pod list when focused
3. Visual indicator shows which panel has focus
4. Selected pod highlighted differently than default pod marker
5. Scrolling works for long pod lists
6. Shift+Tab moves focus backwards

## Tasks / Subtasks

- [x] Extend AppModel with focus and selection state (AC: 1, 3)
  - [x] Add `focusedPanel PanelType` field to AppModel in `internal/tui/app.go`
  - [x] Add `selectedPodIndex int` field to AppModel to track which pod is selected
  - [x] Initialize focusedPanel to PanelNamespaces in NewAppModel()
  - [x] Initialize selectedPodIndex to -1 (no selection initially)
  - [x] Write unit tests for focus state initialization

- [x] Implement Tab/Shift+Tab focus switching (AC: 1, 6)
  - [x] In Update() method, handle tea.KeyMsg for Tab key
  - [x] When Tab pressed, cycle focusedPanel: Namespaces → Pods → Namespaces
  - [x] When Shift+Tab pressed, cycle backwards: Pods → Namespaces → Pods
  - [x] Reset selectedPodIndex to 0 when pod panel gains focus (if pods available)
  - [x] Write unit tests for focus cycling logic

- [x] Implement arrow key navigation in pod panel (AC: 2)
  - [x] In Update() method, handle tea.KeyMsg for Up/Down arrows
  - [x] Only process arrows when focusedPanel == PanelPods
  - [x] Down arrow: increment selectedPodIndex (clamp to len(pods)-1)
  - [x] Up arrow: decrement selectedPodIndex (clamp to 0)
  - [x] Handle empty pod list gracefully (no navigation if len(pods) == 0)
  - [x] Write unit tests for arrow key navigation with various pod list sizes

- [x] Add visual focus indicators to namespace panel (AC: 3)
  - [x] Update `renderNamespacePanel()` in `internal/tui/app.go`
  - [x] When focusedPanel == PanelNamespaces, apply FocusedPanelBorderStyle
  - [x] When focusedPanel != PanelNamespaces, apply UnfocusedPanelBorderStyle
  - [x] Add FocusedPanelBorderStyle and UnfocusedPanelBorderStyle to `internal/tui/styles/styles.go`
  - [x] Ensure border change is visible (e.g., bright border vs. dim border)

- [x] Add visual focus indicators to pod panel (AC: 3)
  - [x] Update `renderPodPanel()` to accept focusedPanel parameter
  - [x] When focusedPanel == PanelPods, apply FocusedPanelBorderStyle
  - [x] When focusedPanel != PanelPods, apply UnfocusedPanelBorderStyle
  - [x] Ensure focus indicator is distinct from pod selection highlighting

- [x] Implement pod selection highlighting (AC: 4)
  - [x] In `renderPodPanel()`, check if pod index matches selectedPodIndex
  - [x] Apply SelectedPodStyle to selected pod (different from DefaultPodStyle)
  - [x] If pod is both selected AND default, show both indicators
  - [x] Example: "★ > api-server-1" where ★=default, >=selected
  - [x] Add SelectedPodStyle to `internal/tui/styles/styles.go` (e.g., inverse/highlighted background)
  - [x] Write rendering tests for selected vs. default vs. both indicators

- [x] Implement scrolling for long pod lists (AC: 5)
  - [x] Calculate visible window based on pod panel height
  - [x] Add `podScrollOffset int` field to AppModel
  - [x] When selectedPodIndex moves beyond visible window, adjust podScrollOffset
  - [x] Render only pods in visible range: pods[podScrollOffset : podScrollOffset+visibleCount]
  - [x] Show scroll indicators if list is truncated (e.g., "↓ 5 more" at bottom)
  - [x] Write unit tests for scroll offset calculation with various list sizes

- [x] Update keyboard bindings documentation (AC: All)
  - [x] Add Tab/Shift+Tab to key bindings in `internal/tui/keys.go`
  - [x] Add Up/Down arrow bindings when pod panel focused
  - [x] Add help text in UI footer showing available keys
  - [x] Ensure help text updates based on focused panel

- [x] Create new styles for focus and selection (AC: 3, 4)
  - [x] Add FocusedPanelBorderStyle to `internal/tui/styles/styles.go` (bright cyan/blue border, thick)
  - [x] Add UnfocusedPanelBorderStyle (gray border, normal)
  - [x] Add SelectedPodStyle (inverse/highlighted background, distinct from default pod marker)
  - [x] Ensure styles are accessible and work in both light/dark terminals

- [x] Add comprehensive unit tests (AC: All)
  - [x] Test focus cycling with Tab and Shift+Tab
  - [x] Test arrow key navigation in pod panel
  - [x] Test arrow keys ignored when namespace panel focused
  - [x] Test selection highlighting in rendering
  - [x] Test scrolling with lists of various sizes (0, 1, 10, 100 pods)
  - [x] Test initialization states (focus on namespaces, no pod selected)
  - [x] Achieve 70%+ test coverage for new focus/selection code

- [x] Integration testing (AC: All)
  - [x] Manual test: Tab through panels and verify focus indicators
  - [x] Manual test: Navigate pod list with arrows and verify selection
  - [x] Manual test: Long pod list (50+ pods) scrolls correctly
  - [x] Manual test: Shift+Tab cycles focus backwards
  - [x] Manual test: Visual distinction between focused panel, selected pod, and default pod
  - [x] Manual test: Arrow keys have no effect when namespace panel focused

## Dev Notes

### Previous Story Insights

From Story 3.2 (Default Pod Pattern Matching):
- AppModel has `defaultPodIndex int` field tracking which pod matches the pattern
- Pod rendering implemented in `renderPodPanel()` in `internal/tui/app.go`
- DefaultPodStyle exists for highlighting default pod with "★" marker
- Pod list stored in `pods []Pod` field of AppModel
- Pod panel already handles empty state, loading state, and error state
- Existing styles: DefaultPodStyle (bright blue), WarningStyle, HelpTextStyle

From Story 2.3 (Namespace Navigation):
- Namespace panel already has selection and navigation implemented
- Namespace list has `selectedNamespaceIndex int` for tracking selection
- Arrow key handling pattern established in Update() method for namespace panel
- Fuzzy search mode uses `searchMode bool` and `searchQuery string` fields
- Namespace panel uses similar visual styling patterns

From Story 1.3 (Kubernetes Context Detection):
- AppModel defined in `internal/tui/app.go`
- Update() method handles tea.KeyMsg events
- View() method orchestrates panel rendering

**Key Technical Decisions:**
- Story 3.3 adds **keyboard navigation** for pod panel - action execution comes in Epic 4
- Focus state managed at AppModel level (central state management)
- Tab cycles forward (Namespaces → Pods), Shift+Tab cycles backward
- Selected pod is different from default pod - both can be shown simultaneously
- Scrolling uses viewport pattern (offset + visible window) for performance

### Data Models - Application State Model

[Source: architecture.md#Data Models - Application State Model]

**AppModel Extensions (add to `internal/tui/app.go`):**

```go
type AppModel struct {
    // ... existing fields from Stories 1.x-3.2 ...

    // Focus and navigation state (NEW for Story 3.3)
    focusedPanel      PanelType  // Which panel has keyboard focus
    selectedPodIndex  int        // Index of selected pod in pods slice (-1 if none)
    podScrollOffset   int        // Scroll offset for long pod lists
}

type PanelType int
const (
    PanelNamespaces PanelType = iota
    PanelPods
    // PanelActions will be added in Epic 4
)
```

**Initialize in NewAppModel():**

```go
func NewAppModel(...) AppModel {
    return AppModel{
        // ... existing initialization ...
        focusedPanel:      PanelNamespaces,  // Start with namespace panel focused
        selectedPodIndex:  -1,                // No pod selected initially
        podScrollOffset:   0,
    }
}
```

### Keyboard Event Handling

[Source: architecture.md#TUI Controller]

**Update() Method - Focus Switching:**

```go
// internal/tui/app.go Update() method
func (m AppModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        switch msg.String() {
        case "tab":
            // Cycle focus forward
            if m.focusedPanel == PanelNamespaces {
                m.focusedPanel = PanelPods
                // Auto-select first pod when focusing pod panel
                if len(m.pods) > 0 && m.selectedPodIndex == -1 {
                    m.selectedPodIndex = 0
                }
            } else if m.focusedPanel == PanelPods {
                m.focusedPanel = PanelNamespaces
            }
            return m, nil

        case "shift+tab":
            // Cycle focus backward
            if m.focusedPanel == PanelPods {
                m.focusedPanel = PanelNamespaces
            } else if m.focusedPanel == PanelNamespaces {
                m.focusedPanel = PanelPods
                if len(m.pods) > 0 && m.selectedPodIndex == -1 {
                    m.selectedPodIndex = 0
                }
            }
            return m, nil

        case "up":
            // Only handle if pod panel focused
            if m.focusedPanel == PanelPods && len(m.pods) > 0 {
                if m.selectedPodIndex > 0 {
                    m.selectedPodIndex--
                    m.adjustScrollOffset()
                }
            }
            return m, nil

        case "down":
            // Only handle if pod panel focused
            if m.focusedPanel == PanelPods && len(m.pods) > 0 {
                if m.selectedPodIndex < len(m.pods)-1 {
                    m.selectedPodIndex++
                    m.adjustScrollOffset()
                }
            }
            return m, nil
        }
    }

    // ... existing message handling ...
}
```

**Scroll Offset Adjustment:**

```go
// internal/tui/app.go
func (m *AppModel) adjustScrollOffset() {
    // Calculate visible window size (based on pod panel height)
    visibleHeight := m.podPanelHeight - 5  // Subtract border, title, help text

    // Scroll down if selection below visible window
    if m.selectedPodIndex >= m.podScrollOffset + visibleHeight {
        m.podScrollOffset = m.selectedPodIndex - visibleHeight + 1
    }

    // Scroll up if selection above visible window
    if m.selectedPodIndex < m.podScrollOffset {
        m.podScrollOffset = m.selectedPodIndex
    }
}
```

### Panel Rendering - Focus Indicators

[Source: architecture.md#TUI Controller]

**Updated `renderNamespacePanel()` Method:**

```go
func (m AppModel) renderNamespacePanel(width, height int) string {
    title := PanelTitleStyle.Render("Namespaces")

    // ... existing content rendering ...

    // Select border style based on focus
    borderStyle := UnfocusedPanelBorderStyle
    if m.focusedPanel == PanelNamespaces {
        borderStyle = FocusedPanelBorderStyle
    }

    fullContent := lipgloss.JoinVertical(lipgloss.Left, title, "", content)

    return borderStyle.
        Width(width - 4).
        Height(height - 2).
        Render(fullContent)
}
```

**Updated `renderPodPanel()` Method:**

```go
func (m AppModel) renderPodPanel(width, height int) string {
    title := PanelTitleStyle.Render("Pods")

    var content string

    if m.podsLoading {
        content = LoadingStyle.Render("Loading pods...")
    } else if m.podsError != nil {
        content = ErrorStyle.Render(fmt.Sprintf("Error: %s", m.podsError.Error()))
    } else if len(m.pods) == 0 {
        content = PlaceholderStyle.Render("No pods in this namespace")
    } else {
        // Calculate visible window
        visibleHeight := height - 5
        visiblePods := m.pods[m.podScrollOffset:]
        if len(visiblePods) > visibleHeight {
            visiblePods = visiblePods[:visibleHeight]
        }

        var podLines []string
        for i, pod := range visiblePods {
            actualIndex := i + m.podScrollOffset
            statusStyle := getPodStatusStyle(pod.Status)

            // Build pod line with markers
            markers := ""

            // Default pod marker
            if actualIndex == m.defaultPodIndex {
                markers += "★ "
            } else {
                markers += "  "
            }

            // Selection marker
            if actualIndex == m.selectedPodIndex {
                markers += "> "
            } else {
                markers += "  "
            }

            // Apply selection highlighting if selected
            podName := pod.Name
            if actualIndex == m.selectedPodIndex {
                podName = SelectedPodStyle.Render(podName)
            } else if actualIndex == m.defaultPodIndex {
                podName = DefaultPodStyle.Render(podName)
            }

            line := fmt.Sprintf("%s%s %s", markers, statusStyle.Render(pod.Status), podName)
            podLines = append(podLines, line)
        }

        content = strings.Join(podLines, "\n")

        // Show scroll indicators
        if m.podScrollOffset > 0 {
            content = HelpTextStyle.Render("↑ More above") + "\n" + content
        }
        if m.podScrollOffset + visibleHeight < len(m.pods) {
            remaining := len(m.pods) - (m.podScrollOffset + visibleHeight)
            content = content + "\n" + HelpTextStyle.Render(fmt.Sprintf("↓ %d more", remaining))
        }

        // Add warning if no match
        if m.defaultPodWarning != "" {
            warningText := WarningStyle.Render(fmt.Sprintf("\n⚠ %s", m.defaultPodWarning))
            content = content + "\n" + warningText
        }

        // Add help text
        helpText := HelpTextStyle.Render("\n★ = Default pod | > = Selected")
        content = content + "\n" + helpText
    }

    // Select border style based on focus
    borderStyle := UnfocusedPanelBorderStyle
    if m.focusedPanel == PanelPods {
        borderStyle = FocusedPanelBorderStyle
    }

    fullContent := lipgloss.JoinVertical(lipgloss.Left, title, "", content)

    return borderStyle.
        Width(width - 4).
        Height(height - 2).
        MaxHeight(height - 2).
        Render(fullContent)
}
```

### Styling Specifications

[Source: architecture.md#TUI Controller]

**New Styles (add to `internal/tui/styles/styles.go`):**

```go
// Focused panel border - bright and prominent
var FocusedPanelBorderStyle = lipgloss.NewStyle().
    BorderStyle(lipgloss.RoundedBorder()).
    BorderForeground(lipgloss.Color("39")).  // Bright cyan
    Padding(1, 2)

// Unfocused panel border - subtle
var UnfocusedPanelBorderStyle = lipgloss.NewStyle().
    BorderStyle(lipgloss.RoundedBorder()).
    BorderForeground(lipgloss.Color("240")).  // Gray
    Padding(1, 2)

// Selected pod highlighting - inverse/highlighted
var SelectedPodStyle = lipgloss.NewStyle().
    Foreground(lipgloss.Color("0")).   // Black text
    Background(lipgloss.Color("39")).  // Bright cyan background
    Bold(true)
```

**Existing Styles (from previous stories):**
- `DefaultPodStyle` - Bright blue for default pod marker (★)
- `PanelTitleStyle` - Panel titles
- `RunningStyle`, `PendingStyle`, `FailedStyle` - Pod status colors
- `LoadingStyle`, `ErrorStyle`, `PlaceholderStyle` - State indicators
- `WarningStyle`, `HelpTextStyle` - Messages

### Keyboard Bindings

[Source: architecture.md#TUI Controller]

**Key Bindings (document in `internal/tui/keys.go`):**

```go
// internal/tui/keys.go

type KeyMap struct {
    // Navigation
    Tab       string  // Switch panel focus forward
    ShiftTab  string  // Switch panel focus backward
    Up        string  // Navigate up in focused panel
    Down      string  // Navigate down in focused panel

    // Search (namespace panel)
    Enter     string  // Select namespace
    Slash     string  // Enter search mode
    Escape    string  // Exit search mode

    // Global
    Quit      string  // Quit application
}

var DefaultKeyMap = KeyMap{
    Tab:      "tab",
    ShiftTab: "shift+tab",
    Up:       "up",
    Down:     "down",
    Enter:    "enter",
    Slash:    "/",
    Escape:   "esc",
    Quit:     "q",
}
```

**Help Text (show in UI footer based on focused panel):**

When namespace panel focused:
```
Tab: Switch Panel | ↑↓: Navigate | /: Search | Enter: Select | q: Quit
```

When pod panel focused:
```
Tab: Switch Panel | ↑↓: Navigate | q: Quit
```

### File Locations

[Source: architecture.md#Source Tree]

**Files to Modify:**
- `internal/tui/app.go` - Add focus state, selection state, scroll offset, update Update() and View() methods
- `internal/tui/app.go` (renderNamespacePanel) - Add focus border styling
- `internal/tui/app.go` (renderPodPanel) - Add focus border styling, selection highlighting, scrolling
- `internal/tui/styles/styles.go` - Add FocusedPanelBorderStyle, UnfocusedPanelBorderStyle, SelectedPodStyle

**Files to Create:**
- `internal/tui/keys.go` - Keyboard binding definitions and help text

**Files to Extend with Tests:**
- `internal/tui/app_test.go` - Focus cycling tests, navigation tests, rendering tests
- `internal/tui/focus_test.go` - New file for focus-specific tests
- `internal/tui/navigation_test.go` - New file for pod navigation tests

### Testing

[Source: architecture.md#Test Strategy and Standards]

**Test Framework:** Go stdlib `testing` package with `testify/assert` and `testify/require`

**Test File Locations:**
- `internal/tui/app_test.go` - Extend with focus and navigation tests
- `internal/tui/focus_test.go` - New file for focus management tests
- `internal/tui/navigation_test.go` - New file for pod navigation and scrolling tests

**Coverage Requirement:** 70% minimum

**Test Cases:**

**Focus Cycling Tests:**
```go
func TestFocusCycling_Tab(t *testing.T) {
    tests := []struct {
        name           string
        initialFocus   PanelType
        keyPress       string
        expectedFocus  PanelType
    }{
        {
            name:          "Tab from namespaces to pods",
            initialFocus:  PanelNamespaces,
            keyPress:      "tab",
            expectedFocus: PanelPods,
        },
        {
            name:          "Tab from pods to namespaces",
            initialFocus:  PanelPods,
            keyPress:      "tab",
            expectedFocus: PanelNamespaces,
        },
        {
            name:          "Shift+Tab from pods to namespaces",
            initialFocus:  PanelPods,
            keyPress:      "shift+tab",
            expectedFocus: PanelNamespaces,
        },
        {
            name:          "Shift+Tab from namespaces to pods",
            initialFocus:  PanelNamespaces,
            keyPress:      "shift+tab",
            expectedFocus: PanelPods,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            model := AppModel{
                focusedPanel: tt.initialFocus,
                pods: []Pod{{Name: "test-pod"}},  // Need pods for focus switch
            }

            msg := tea.KeyMsg{Type: tea.KeyType(tt.keyPress)}
            updatedModel, _ := model.Update(msg)
            m := updatedModel.(AppModel)

            assert.Equal(t, tt.expectedFocus, m.focusedPanel)
        })
    }
}
```

**Pod Navigation Tests:**
```go
func TestPodNavigation_ArrowKeys(t *testing.T) {
    tests := []struct {
        name           string
        initialIndex   int
        keyPress       string
        focusedPanel   PanelType
        pods           []Pod
        expectedIndex  int
    }{
        {
            name:          "Down arrow increments selection",
            initialIndex:  0,
            keyPress:      "down",
            focusedPanel:  PanelPods,
            pods:          []Pod{{Name: "pod-1"}, {Name: "pod-2"}, {Name: "pod-3"}},
            expectedIndex: 1,
        },
        {
            name:          "Up arrow decrements selection",
            initialIndex:  2,
            keyPress:      "up",
            focusedPanel:  PanelPods,
            pods:          []Pod{{Name: "pod-1"}, {Name: "pod-2"}, {Name: "pod-3"}},
            expectedIndex: 1,
        },
        {
            name:          "Down arrow clamped at last pod",
            initialIndex:  2,
            keyPress:      "down",
            focusedPanel:  PanelPods,
            pods:          []Pod{{Name: "pod-1"}, {Name: "pod-2"}, {Name: "pod-3"}},
            expectedIndex: 2,  // No change
        },
        {
            name:          "Up arrow clamped at first pod",
            initialIndex:  0,
            keyPress:      "up",
            focusedPanel:  PanelPods,
            pods:          []Pod{{Name: "pod-1"}, {Name: "pod-2"}},
            expectedIndex: 0,  // No change
        },
        {
            name:          "Arrow keys ignored when namespace focused",
            initialIndex:  1,
            keyPress:      "down",
            focusedPanel:  PanelNamespaces,
            pods:          []Pod{{Name: "pod-1"}, {Name: "pod-2"}, {Name: "pod-3"}},
            expectedIndex: 1,  // No change
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            model := AppModel{
                focusedPanel:     tt.focusedPanel,
                selectedPodIndex: tt.initialIndex,
                pods:             tt.pods,
            }

            msg := tea.KeyMsg{Type: tea.KeyType(tt.keyPress)}
            updatedModel, _ := model.Update(msg)
            m := updatedModel.(AppModel)

            assert.Equal(t, tt.expectedIndex, m.selectedPodIndex)
        })
    }
}
```

**Scrolling Tests:**
```go
func TestPodScrolling(t *testing.T) {
    // Create a long pod list (50 pods)
    pods := make([]Pod, 50)
    for i := range pods {
        pods[i] = Pod{Name: fmt.Sprintf("pod-%d", i)}
    }

    tests := []struct {
        name              string
        initialIndex      int
        initialOffset     int
        keyPress          string
        panelHeight       int
        expectedIndex     int
        expectedOffset    int
    }{
        {
            name:           "Scrolling down when selection at bottom of window",
            initialIndex:   9,
            initialOffset:  0,
            keyPress:       "down",
            panelHeight:    15,  // 10 visible pods
            expectedIndex:  10,
            expectedOffset: 1,   // Scroll down by 1
        },
        {
            name:           "Scrolling up when selection at top of window",
            initialIndex:   10,
            initialOffset:  10,
            keyPress:       "up",
            panelHeight:    15,
            expectedIndex:  9,
            expectedOffset: 9,   // Scroll up by 1
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            model := AppModel{
                focusedPanel:     PanelPods,
                selectedPodIndex: tt.initialIndex,
                podScrollOffset:  tt.initialOffset,
                pods:             pods,
                podPanelHeight:   tt.panelHeight,
            }

            msg := tea.KeyMsg{Type: tea.KeyType(tt.keyPress)}
            updatedModel, _ := model.Update(msg)
            m := updatedModel.(AppModel)

            assert.Equal(t, tt.expectedIndex, m.selectedPodIndex)
            assert.Equal(t, tt.expectedOffset, m.podScrollOffset)
        })
    }
}
```

**Rendering Tests:**
```go
func TestRenderPodPanel_FocusAndSelection(t *testing.T) {
    tests := []struct {
        name             string
        model            AppModel
        wantContains     []string
        wantNotContain   []string
    }{
        {
            name: "focused panel shows bright border",
            model: AppModel{
                focusedPanel:     PanelPods,
                pods:             []Pod{{Name: "pod-1", Status: "Running"}},
                selectedPodIndex: 0,
            },
            wantContains: []string{"pod-1", ">"},  // Selection marker
        },
        {
            name: "unfocused panel shows dim border",
            model: AppModel{
                focusedPanel:     PanelNamespaces,
                pods:             []Pod{{Name: "pod-1", Status: "Running"}},
                selectedPodIndex: -1,
            },
            wantContains:   []string{"pod-1"},
            wantNotContain: []string{">"},  // No selection marker when unfocused
        },
        {
            name: "selected and default pod both shown",
            model: AppModel{
                focusedPanel:     PanelPods,
                pods:             []Pod{{Name: "api-pod", Status: "Running"}},
                selectedPodIndex: 0,
                defaultPodIndex:  0,
            },
            wantContains: []string{"★", ">", "api-pod"},
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            output := tt.model.renderPodPanel(40, 20)

            for _, text := range tt.wantContains {
                assert.Contains(t, output, text)
            }
            for _, text := range tt.wantNotContain {
                assert.NotContains(t, output, text)
            }
        })
    }
}
```

### Technical Constraints

[Source: architecture.md#Tech Stack]

**Go Version:** 1.21+

**Dependencies (already in project):**
- Bubble Tea v0.25+
- Lip Gloss v0.9+

**No new dependencies needed for this story.**

**Performance Requirements:**
- Focus switching: instant (no perceptible delay)
- Arrow key navigation: instant (no perceptible delay)
- Scrolling: smooth, no lag even with 100+ pods
- Panel rendering: <16ms per frame (60fps target)

### Integration with Existing Code

[Source: architecture.md#Core Workflows]

**State Reset on Namespace Change:**

When user switches namespaces (in Update() when handling namespace selection):

```go
case NamespaceSelectedMsg:
    m.currentNamespace = msg.Namespace
    m.pods = nil
    m.podsLoading = true

    // Reset pod panel state
    m.selectedPodIndex = -1
    m.defaultPodIndex = -1
    m.podScrollOffset = 0
    m.defaultPodWarning = ""

    // Fetch new pods
    return m, fetchPods(m.currentContext, m.currentNamespace)
```

**Auto-selection on Focus:**

When pod panel gains focus via Tab/Shift+Tab, automatically select first pod if none selected:

```go
case "tab":
    if m.focusedPanel == PanelNamespaces {
        m.focusedPanel = PanelPods
        // Auto-select first pod if available and nothing selected
        if len(m.pods) > 0 && m.selectedPodIndex == -1 {
            m.selectedPodIndex = 0
        }
    }
```

**Coordination with Namespace Panel:**

Namespace panel already has navigation (arrows, search). When namespace panel is focused:
- Arrow keys continue to navigate namespace list
- Tab switches to pod panel
- This story does NOT change namespace panel behavior

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-04 | 1.0 | Initial story creation | SM (Bob) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

N/A - No blocking issues encountered

### Completion Notes List

- Successfully implemented all keyboard navigation features (Tab, Shift+Tab, Up/Down arrows)
- Added focus indicators using bright cyan borders for focused panels, gray for unfocused
- Implemented pod selection highlighting with inverse colors (black on cyan)
- Created scrolling mechanism for long pod lists with scroll indicators
- Auto-select first pod when focusing pod panel for better UX
- Updated keyboard bindings documentation in keys.go
- Created comprehensive test suite with 91.4% coverage
- All acceptance criteria validated through unit tests
- Build successful with no errors

### File List

**Modified:**
- internal/tui/app.go - Added PanelType enum, focus state fields, Tab/Shift+Tab handling, arrow key navigation, scroll logic, rendering updates
- internal/tui/keys.go - Added Tab and ShiftTab key bindings
- internal/tui/styles/styles.go - Added FocusedPanelBorderStyle, UnfocusedPanelBorderStyle, SelectedPodStyle

**Created:**
- internal/tui/focus_test.go - Tests for focus cycling and initialization
- internal/tui/navigation_test.go - Tests for pod navigation, scrolling, and state reset

## QA Results

### Review Date: 2025-10-04

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Quality: Excellent**

The implementation of Story 3.3 (Pod List Navigation) demonstrates exemplary software engineering practices. The code is clean, well-structured, and follows established patterns from previous stories. All acceptance criteria have been fully implemented with comprehensive test coverage (91.3%).

**Strengths:**
- Clean separation of concerns with focus state managed at AppModel level
- Consistent use of Bubble Tea's Model-View-Update pattern
- Excellent test coverage with both unit and integration test scenarios
- Proper scroll offset management for handling long pod lists
- Auto-selection UX enhancement when focusing pod panel
- Clear visual indicators for both focus (border color) and selection (background highlight)
- All keyboard bindings properly documented in keys.go

**Code Organization:**
- Focus management logic centralized in Update() method
- Scroll adjustment logic extracted to dedicated method (`adjustPodScrollOffset`)
- Rendering logic properly handles all edge cases (empty lists, single pod, long lists)
- State reset logic properly implemented on namespace changes

### Refactoring Performed

No refactoring was necessary. The implementation is already well-structured and follows best practices.

### Compliance Check

- **Coding Standards:** ✓ Excellent
  - Follows Go conventions and idioms
  - Proper use of constants for PanelType enumeration
  - Clear comments documenting Story 3.3 additions
  - Consistent naming conventions throughout

- **Project Structure:** ✓ Compliant
  - Files organized according to architecture.md specifications
  - Test files properly co-located with implementation
  - Styles centralized in styles package

- **Testing Strategy:** ✓ Exceeds Requirements
  - 91.3% test coverage (exceeds 70% requirement)
  - Comprehensive test scenarios covering:
    - Focus cycling (Tab and Shift+Tab)
    - Arrow key navigation with boundary conditions
    - Scrolling with various list sizes
    - State reset on namespace changes
    - Empty and single-item edge cases
  - Tests properly use testify/assert framework

- **All ACs Met:** ✓ Complete
  - AC 1: Tab key switches focus between panels ✓
  - AC 2: Arrow keys navigate pod list when focused ✓
  - AC 3: Visual indicators for panel focus ✓
  - AC 4: Selected pod highlighted distinctly from default pod ✓
  - AC 5: Scrolling works for long pod lists ✓
  - AC 6: Shift+Tab moves focus backwards ✓

### Improvements Checklist

All items completed by developer:

- [x] Comprehensive focus cycling implementation with Tab/Shift+Tab
- [x] Arrow key navigation with proper focus awareness
- [x] Visual focus indicators (bright cyan vs gray borders)
- [x] Pod selection highlighting (inverse colors)
- [x] Scroll management for long lists with indicators
- [x] Auto-selection UX enhancement
- [x] State reset on namespace changes
- [x] Comprehensive test suite (91.3% coverage)
- [x] Keyboard bindings documentation

No additional improvements recommended.

### Security Review

**Status: PASS**

No security concerns identified. This is a UI navigation feature with no:
- External input handling beyond keyboard events
- Data persistence or transmission
- Authentication or authorization logic
- Resource consumption risks

### Performance Considerations

**Status: PASS**

Performance is excellent:
- Focus switching is instant (O(1) operations)
- Arrow key navigation is instant (O(1) index updates)
- Scroll offset adjustment is O(1)
- Rendering only visible pods (viewport optimization)
- No memory leaks or unbounded growth

**Optimization Highlights:**
- Viewport rendering (only visible pods rendered, not entire list)
- Efficient scroll offset calculation
- Minimal state updates on navigation

### Technical Debt Assessment

**Status: None Identified**

No technical debt introduced. The implementation:
- Follows established patterns from previous stories
- Maintains consistency with existing codebase
- Properly documents future extension points (PanelActions comment)
- No shortcuts or workarounds used

### Requirements Traceability

**AC 1: Tab key switches focus between namespace and pod panels**
- ✓ Implemented in app.go:270-297 (Tab and Shift+Tab handlers)
- ✓ Tested in focus_test.go:13-61 (TestFocusCycling_Tab)
- ✓ Tested in focus_test.go:64-113 (TestFocusCycling_ShiftTab)

**AC 2: Arrow keys navigate pod list when focused**
- ✓ Implemented in app.go:365-435 (Up/Down arrow handlers with focus check)
- ✓ Tested in navigation_test.go:13-81 (TestPodNavigation_ArrowKeys)
- ✓ Edge cases tested: empty list, single pod, boundary clamping

**AC 3: Visual indicator shows which panel has focus**
- ✓ Implemented in styles/styles.go:110-122 (FocusedPanelBorderStyle, UnfocusedPanelBorderStyle)
- ✓ Applied in app.go:922-928 (renderNamespacePanel)
- ✓ Applied in app.go:1035-1040 (renderPodPanel)

**AC 4: Selected pod highlighted differently than default pod marker**
- ✓ Implemented in styles/styles.go:124-129 (SelectedPodStyle)
- ✓ Rendering logic in app.go:980-1005 (dual marker system: ★ and >)
- ✓ Help text updated in app.go:1029 (★ = Default pod | > = Selected)

**AC 5: Scrolling works for long pod lists**
- ✓ Scroll offset logic in app.go:544-565 (adjustPodScrollOffset)
- ✓ Viewport rendering in app.go:957-970 (visible pod calculation)
- ✓ Scroll indicators in app.go:1012-1020
- ✓ Tested in navigation_test.go:84-149 (TestPodScrolling)

**AC 6: Shift+Tab moves focus backwards**
- ✓ Implemented in app.go:285-296 (Shift+Tab handler)
- ✓ Tested in focus_test.go:64-113 (TestFocusCycling_ShiftTab)

### Test Architecture Quality

**Excellent Test Design:**

1. **Focus Management Tests** (focus_test.go):
   - Comprehensive focus cycling scenarios (both directions)
   - Initialization state verification
   - Auto-selection behavior validation
   - Edge case: already selected pod handling

2. **Navigation Tests** (navigation_test.go):
   - Arrow key navigation with all boundary conditions
   - Scroll offset calculations with realistic terminal sizes
   - State reset verification
   - Empty list and single-item edge cases

3. **Test Quality Attributes:**
   - **Controllability:** ✓ Tests fully control initial state
   - **Observability:** ✓ All assertions check expected outcomes
   - **Debuggability:** ✓ Clear test names and failure messages
   - **Isolation:** ✓ Each test is independent
   - **Coverage:** ✓ 91.3% statement coverage

### Files Modified During Review

None - implementation is complete and high quality.

### Gate Status

**Gate: PASS** → docs/qa/gates/3.3-pod-list-navigation.yml

Quality score: 100/100

### Recommended Status

**✓ Ready for Done**

This story is complete, fully tested, and ready for production. All acceptance criteria met, excellent code quality, comprehensive test coverage, and no issues identified.
